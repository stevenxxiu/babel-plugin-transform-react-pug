// generated by scripts/generate-babel-types.js

type Location = {start: {line: number, column: number}, end: {line: number, column: number}};

declare class AnyTypeAnnotation {
  type: 'AnyTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowType
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class ArrayExpression {
  type: 'ArrayExpression';
  loc: ?Location;
  elements: $ReadOnlyArray<null | Expression | SpreadElement>;

  // alias: Expression
  // alias: BabelNode
}

declare class ArrayPattern {
  type: 'ArrayPattern';
  loc: ?Location;
  elements: $ReadOnlyArray<PatternLike>;
  decorators: ?$ReadOnlyArray<Decorator>;
  typeAnnotation: ?TypeAnnotation | TSTypeAnnotation | Noop;

  // alias: Pattern
  // alias: PatternLike
  // alias: LVal
  // alias: BabelNode
}

declare class ArrayTypeAnnotation {
  type: 'ArrayTypeAnnotation';
  loc: ?Location;
  elementType: FlowType;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class ArrowFunctionExpression {
  type: 'ArrowFunctionExpression';
  loc: ?Location;
  params: $ReadOnlyArray<LVal>;
  body: BlockStatement | Expression;
  async: ?boolean;
  expression: ?boolean;
  generator: ?boolean;
  returnType: ?TypeAnnotation | TSTypeAnnotation | Noop;
  typeParameters: ?TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;

  // alias: Scopable
  // alias: Function
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Expression
  // alias: Pureish
  // alias: BabelNode
}

declare class AssignmentExpression {
  type: 'AssignmentExpression';
  loc: ?Location;
  operator: string;
  left: LVal;
  right: Expression;

  // alias: Expression
  // alias: BabelNode
}

declare class AssignmentPattern {
  type: 'AssignmentPattern';
  loc: ?Location;
  left: Identifier | ObjectPattern | ArrayPattern;
  right: Expression;
  decorators: ?$ReadOnlyArray<Decorator>;
  typeAnnotation: ?TypeAnnotation | TSTypeAnnotation | Noop;

  // alias: Pattern
  // alias: PatternLike
  // alias: LVal
  // alias: BabelNode
}

declare class AwaitExpression {
  type: 'AwaitExpression';
  loc: ?Location;
  argument: Expression;

  // alias: Expression
  // alias: Terminatorless
  // alias: BabelNode
}

declare class BinaryExpression {
  type: 'BinaryExpression';
  loc: ?Location;
  operator: '+' | '-' | '/' | '%' | '*' | '**' | '&' | '|' | '>>' | '>>>' | '<<' | '^' | '==' | '===' | '!=' | '!==' | 'in' | 'instanceof' | '>' | '<' | '>=' | '<=';
  left: Expression;
  right: Expression;

  // alias: Binary
  // alias: Expression
  // alias: BabelNode
}

declare class BindExpression {
  type: 'BindExpression';
  loc: ?Location;
  object: mixed;
  callee: mixed;

  // alias: Expression
  // alias: BabelNode
}

declare class BlockStatement {
  type: 'BlockStatement';
  loc: ?Location;
  body: $ReadOnlyArray<Statement>;
  directives: $ReadOnlyArray<Directive>;

  // alias: Scopable
  // alias: BlockParent
  // alias: Block
  // alias: Statement
  // alias: BabelNode
}

declare class BooleanLiteral {
  type: 'BooleanLiteral';
  loc: ?Location;
  value: boolean;

  // alias: Expression
  // alias: Pureish
  // alias: Literal
  // alias: Immutable
  // alias: BabelNode
}

declare class BooleanLiteralTypeAnnotation {
  type: 'BooleanLiteralTypeAnnotation';
  loc: ?Location;
  value: ?boolean;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class BooleanTypeAnnotation {
  type: 'BooleanTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowType
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class BreakStatement {
  type: 'BreakStatement';
  loc: ?Location;
  label: ?Identifier;

  // alias: Statement
  // alias: Terminatorless
  // alias: CompletionStatement
  // alias: BabelNode
}

declare class CallExpression {
  type: 'CallExpression';
  loc: ?Location;
  callee: Expression;
  arguments: $ReadOnlyArray<Expression | SpreadElement | JSXNamespacedName>;
  optional: ?true | false;
  typeParameters: ?TypeParameterInstantiation | TSTypeParameterInstantiation;

  // alias: Expression
  // alias: BabelNode
}

declare class CatchClause {
  type: 'CatchClause';
  loc: ?Location;
  param: ?Identifier;
  body: BlockStatement;

  // alias: Scopable
  // alias: BlockParent
  // alias: BabelNode
}

declare class ClassBody {
  type: 'ClassBody';
  loc: ?Location;
  body: $ReadOnlyArray<ClassMethod | ClassProperty | TSDeclareMethod | TSIndexSignature>;

  // alias: BabelNode
}

declare class ClassDeclaration {
  type: 'ClassDeclaration';
  loc: ?Location;
  id: ?Identifier;
  superClass: ?Expression;
  body: ClassBody;
  decorators: ?$ReadOnlyArray<Decorator>;
  abstract: ?boolean;
  declare: ?boolean;
  implements: ?$ReadOnlyArray<TSExpressionWithTypeArguments | FlowClassImplements>;
  mixins: ?mixed;
  superTypeParameters: ?TypeParameterInstantiation | TSTypeParameterInstantiation;
  typeParameters: ?TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;

  // alias: Scopable
  // alias: Class
  // alias: Statement
  // alias: Declaration
  // alias: Pureish
  // alias: BabelNode
}

declare class ClassExpression {
  type: 'ClassExpression';
  loc: ?Location;
  id: ?Identifier;
  superClass: ?Expression;
  body: ClassBody;
  decorators: ?$ReadOnlyArray<Decorator>;
  implements: ?$ReadOnlyArray<TSExpressionWithTypeArguments | FlowClassImplements>;
  mixins: ?mixed;
  superTypeParameters: ?TypeParameterInstantiation | TSTypeParameterInstantiation;
  typeParameters: ?TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;

  // alias: Scopable
  // alias: Class
  // alias: Expression
  // alias: Pureish
  // alias: BabelNode
}

declare class ClassImplements {
  type: 'ClassImplements';
  loc: ?Location;
  id: Identifier;
  typeParameters: ?TypeParameterInstantiation;

  // alias: Flow
  // alias: BabelNode
}

declare class ClassMethod {
  type: 'ClassMethod';
  loc: ?Location;
  kind: ?"get" | "set" | "method" | "constructor";
  key: Expression;
  params: $ReadOnlyArray<LVal>;
  body: BlockStatement;
  computed: ?boolean;
  abstract: ?boolean;
  access: ?"public" | "private" | "protected";
  accessibility: ?"public" | "private" | "protected";
  async: ?boolean;
  decorators: ?$ReadOnlyArray<Decorator>;
  generator: ?boolean;
  optional: ?boolean;
  returnType: ?TypeAnnotation | TSTypeAnnotation | Noop;
  typeParameters: ?TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;

  // alias: Function
  // alias: Scopable
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Method
  // alias: BabelNode
}

declare class ClassProperty {
  type: 'ClassProperty';
  loc: ?Location;
  key: mixed;
  value: ?Expression;
  typeAnnotation: ?TypeAnnotation | TSTypeAnnotation | Noop;
  decorators: ?$ReadOnlyArray<Decorator>;
  computed: ?boolean;
  abstract: ?boolean;
  accessibility: ?"public" | "private" | "protected";
  optional: ?boolean;
  readonly: ?boolean;

  // alias: Property
  // alias: BabelNode
}

declare class ConditionalExpression {
  type: 'ConditionalExpression';
  loc: ?Location;
  test: Expression;
  consequent: Expression;
  alternate: Expression;

  // alias: Expression
  // alias: Conditional
  // alias: BabelNode
}

declare class ContinueStatement {
  type: 'ContinueStatement';
  loc: ?Location;
  label: ?Identifier;

  // alias: Statement
  // alias: Terminatorless
  // alias: CompletionStatement
  // alias: BabelNode
}

declare class DebuggerStatement {
  type: 'DebuggerStatement';
  loc: ?Location;

  // alias: Statement
  // alias: BabelNode
}

declare class DeclareClass {
  type: 'DeclareClass';
  loc: ?Location;
  id: Identifier;
  typeParameters: ?TypeParameterInstantiation;
  extends: ?$ReadOnlyArray<InterfaceExtends>;
  body: ObjectTypeAnnotation;
  mixins: ?$ReadOnlyArray<InterfaceExtends>;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareExportAllDeclaration {
  type: 'DeclareExportAllDeclaration';
  loc: ?Location;
  source: StringLiteral;
  exportKind: ?[ 'type', 'value' ];

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareExportDeclaration {
  type: 'DeclareExportDeclaration';
  loc: ?Location;
  declaration: ?Flow;
  specifiers: ?$ReadOnlyArray<ExportSpecifier | ExportNamespaceSpecifier>;
  source: ?StringLiteral;
  default: ?boolean;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareFunction {
  type: 'DeclareFunction';
  loc: ?Location;
  id: Identifier;
  predicate: ?DeclaredPredicate;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareInterface {
  type: 'DeclareInterface';
  loc: ?Location;
  id: Identifier;
  typeParameters: ?TypeParameterDeclaration;
  extends: ?InterfaceExtends;
  body: ObjectTypeAnnotation;
  mixins: ?$ReadOnlyArray<Flow>;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareModule {
  type: 'DeclareModule';
  loc: ?Location;
  id: Identifier | StringLiteral;
  body: BlockStatement;
  kind: ?'CommonJS' | 'ES';

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareModuleExports {
  type: 'DeclareModuleExports';
  loc: ?Location;
  typeAnnotation: TypeAnnotation;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareOpaqueType {
  type: 'DeclareOpaqueType';
  loc: ?Location;
  id: Identifier;
  typeParameters: ?TypeParameterDeclaration;
  supertype: ?FlowType;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareTypeAlias {
  type: 'DeclareTypeAlias';
  loc: ?Location;
  id: Identifier;
  typeParameters: ?TypeParameterDeclaration;
  right: FlowType;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclareVariable {
  type: 'DeclareVariable';
  loc: ?Location;
  id: Identifier;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class DeclaredPredicate {
  type: 'DeclaredPredicate';
  loc: ?Location;
  value: Flow;

  // alias: Flow
  // alias: FlowPredicate
  // alias: BabelNode
}

declare class Decorator {
  type: 'Decorator';
  loc: ?Location;
  expression: Expression;

  // alias: BabelNode
}

declare class Directive {
  type: 'Directive';
  loc: ?Location;
  value: DirectiveLiteral;

  // alias: BabelNode
}

declare class DirectiveLiteral {
  type: 'DirectiveLiteral';
  loc: ?Location;
  value: string;

  // alias: BabelNode
}

declare class DoExpression {
  type: 'DoExpression';
  loc: ?Location;
  body: BlockStatement;

  // alias: Expression
  // alias: BabelNode
}

declare class DoWhileStatement {
  type: 'DoWhileStatement';
  loc: ?Location;
  test: Expression;
  body: Statement;

  // alias: Statement
  // alias: BlockParent
  // alias: Loop
  // alias: While
  // alias: Scopable
  // alias: BabelNode
}

declare class EmptyStatement {
  type: 'EmptyStatement';
  loc: ?Location;

  // alias: Statement
  // alias: BabelNode
}

declare class EmptyTypeAnnotation {
  type: 'EmptyTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowType
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class ExistsTypeAnnotation {
  type: 'ExistsTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class ExportAllDeclaration {
  type: 'ExportAllDeclaration';
  loc: ?Location;
  source: StringLiteral;

  // alias: Statement
  // alias: Declaration
  // alias: ModuleDeclaration
  // alias: ExportDeclaration
  // alias: BabelNode
}

declare class ExportDefaultDeclaration {
  type: 'ExportDefaultDeclaration';
  loc: ?Location;
  declaration: FunctionDeclaration | TSDeclareFunction | ClassDeclaration | Expression;

  // alias: Statement
  // alias: Declaration
  // alias: ModuleDeclaration
  // alias: ExportDeclaration
  // alias: BabelNode
}

declare class ExportDefaultSpecifier {
  type: 'ExportDefaultSpecifier';
  loc: ?Location;
  exported: Identifier;

  // alias: ModuleSpecifier
  // alias: BabelNode
}

declare class ExportNamedDeclaration {
  type: 'ExportNamedDeclaration';
  loc: ?Location;
  declaration: ?Declaration;
  specifiers: $ReadOnlyArray<ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier>;
  source: ?StringLiteral;

  // alias: Statement
  // alias: Declaration
  // alias: ModuleDeclaration
  // alias: ExportDeclaration
  // alias: BabelNode
}

declare class ExportNamespaceSpecifier {
  type: 'ExportNamespaceSpecifier';
  loc: ?Location;
  exported: Identifier;

  // alias: ModuleSpecifier
  // alias: BabelNode
}

declare class ExportSpecifier {
  type: 'ExportSpecifier';
  loc: ?Location;
  local: Identifier;
  exported: Identifier;

  // alias: ModuleSpecifier
  // alias: BabelNode
}

declare class ExpressionStatement {
  type: 'ExpressionStatement';
  loc: ?Location;
  expression: Expression;

  // alias: Statement
  // alias: ExpressionWrapper
  // alias: BabelNode
}

declare class File {
  type: 'File';
  loc: ?Location;
  program: Program;
  comments: mixed;
  tokens: mixed;

  // alias: BabelNode
}

declare class ForInStatement {
  type: 'ForInStatement';
  loc: ?Location;
  left: VariableDeclaration | LVal;
  right: Expression;
  body: Statement;

  // alias: Scopable
  // alias: Statement
  // alias: For
  // alias: BlockParent
  // alias: Loop
  // alias: ForXStatement
  // alias: BabelNode
}

declare class ForOfStatement {
  type: 'ForOfStatement';
  loc: ?Location;
  left: VariableDeclaration | LVal;
  right: Expression;
  body: Statement;
  await: ?boolean;

  // alias: Scopable
  // alias: Statement
  // alias: For
  // alias: BlockParent
  // alias: Loop
  // alias: ForXStatement
  // alias: BabelNode
}

declare class ForStatement {
  type: 'ForStatement';
  loc: ?Location;
  init: ?VariableDeclaration | Expression;
  test: ?Expression;
  update: ?Expression;
  body: Statement;

  // alias: Scopable
  // alias: Statement
  // alias: For
  // alias: BlockParent
  // alias: Loop
  // alias: BabelNode
}

declare class FunctionDeclaration {
  type: 'FunctionDeclaration';
  loc: ?Location;
  id: ?Identifier;
  params: $ReadOnlyArray<LVal>;
  body: BlockStatement;
  generator: ?boolean;
  async: ?boolean;
  declare: ?boolean;
  returnType: ?TypeAnnotation | TSTypeAnnotation | Noop;
  typeParameters: ?TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;

  // alias: Scopable
  // alias: Function
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Statement
  // alias: Pureish
  // alias: Declaration
  // alias: BabelNode
}

declare class FunctionExpression {
  type: 'FunctionExpression';
  loc: ?Location;
  id: ?Identifier;
  params: $ReadOnlyArray<LVal>;
  body: BlockStatement;
  generator: ?boolean;
  async: ?boolean;
  returnType: ?TypeAnnotation | TSTypeAnnotation | Noop;
  typeParameters: ?TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;

  // alias: Scopable
  // alias: Function
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Expression
  // alias: Pureish
  // alias: BabelNode
}

declare class FunctionTypeAnnotation {
  type: 'FunctionTypeAnnotation';
  loc: ?Location;
  typeParameters: ?TypeParameterDeclaration;
  params: $ReadOnlyArray<FunctionTypeParam>;
  rest: ?FunctionTypeParam;
  returnType: FlowType;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class FunctionTypeParam {
  type: 'FunctionTypeParam';
  loc: ?Location;
  name: ?Identifier;
  typeAnnotation: FlowType;
  optional: ?boolean;

  // alias: Flow
  // alias: BabelNode
}

declare class GenericTypeAnnotation {
  type: 'GenericTypeAnnotation';
  loc: ?Location;
  id: Identifier;
  typeParameters: ?TypeParameterInstantiation;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class Identifier {
  type: 'Identifier';
  loc: ?Location;
  name: string;
  decorators: ?$ReadOnlyArray<Decorator>;
  optional: ?boolean;
  typeAnnotation: ?TypeAnnotation | TSTypeAnnotation | Noop;

  // alias: Expression
  // alias: PatternLike
  // alias: LVal
  // alias: TSEntityName
  // alias: BabelNode
}

declare class IfStatement {
  type: 'IfStatement';
  loc: ?Location;
  test: Expression;
  consequent: Statement;
  alternate: ?Statement;

  // alias: Statement
  // alias: Conditional
  // alias: BabelNode
}

declare class Import {
  type: 'Import';
  loc: ?Location;

  // alias: Expression
  // alias: BabelNode
}

declare class ImportDeclaration {
  type: 'ImportDeclaration';
  loc: ?Location;
  specifiers: $ReadOnlyArray<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>;
  source: StringLiteral;

  // alias: Statement
  // alias: Declaration
  // alias: ModuleDeclaration
  // alias: BabelNode
}

declare class ImportDefaultSpecifier {
  type: 'ImportDefaultSpecifier';
  loc: ?Location;
  local: Identifier;

  // alias: ModuleSpecifier
  // alias: BabelNode
}

declare class ImportNamespaceSpecifier {
  type: 'ImportNamespaceSpecifier';
  loc: ?Location;
  local: Identifier;

  // alias: ModuleSpecifier
  // alias: BabelNode
}

declare class ImportSpecifier {
  type: 'ImportSpecifier';
  loc: ?Location;
  local: Identifier;
  imported: Identifier;
  importKind: ?null | 'type' | 'typeof';

  // alias: ModuleSpecifier
  // alias: BabelNode
}

declare class InferredPredicate {
  type: 'InferredPredicate';
  loc: ?Location;

  // alias: Flow
  // alias: FlowPredicate
  // alias: BabelNode
}

declare class InterfaceDeclaration {
  type: 'InterfaceDeclaration';
  loc: ?Location;
  id: Identifier;
  typeParameters: ?TypeParameterDeclaration;
  extends: $ReadOnlyArray<InterfaceExtends>;
  body: ObjectTypeAnnotation;
  mixins: ?$ReadOnlyArray<InterfaceExtends>;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class InterfaceExtends {
  type: 'InterfaceExtends';
  loc: ?Location;
  id: Identifier;
  typeParameters: ?TypeParameterInstantiation;

  // alias: Flow
  // alias: BabelNode
}

declare class IntersectionTypeAnnotation {
  type: 'IntersectionTypeAnnotation';
  loc: ?Location;
  types: $ReadOnlyArray<FlowType>;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class JSXAttribute {
  type: 'JSXAttribute';
  loc: ?Location;
  name: JSXIdentifier | JSXNamespacedName;
  value: ?JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class JSXClosingElement {
  type: 'JSXClosingElement';
  loc: ?Location;
  name: JSXIdentifier | JSXMemberExpression;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class JSXClosingFragment {
  type: 'JSXClosingFragment';
  loc: ?Location;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class JSXElement {
  type: 'JSXElement';
  loc: ?Location;
  openingElement: JSXOpeningElement;
  closingElement: ?JSXClosingElement;
  children: $ReadOnlyArray<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>;
  selfClosing: mixed;

  // alias: JSX
  // alias: Immutable
  // alias: Expression
  // alias: BabelNode
}

declare class JSXEmptyExpression {
  type: 'JSXEmptyExpression';
  loc: ?Location;

  // alias: JSX
  // alias: BabelNode
}

declare class JSXExpressionContainer {
  type: 'JSXExpressionContainer';
  loc: ?Location;
  expression: Expression;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class JSXFragment {
  type: 'JSXFragment';
  loc: ?Location;
  openingFragment: JSXOpeningFragment;
  closingFragment: JSXClosingFragment;
  children: $ReadOnlyArray<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>;

  // alias: JSX
  // alias: Immutable
  // alias: Expression
  // alias: BabelNode
}

declare class JSXIdentifier {
  type: 'JSXIdentifier';
  loc: ?Location;
  name: string;

  // alias: JSX
  // alias: BabelNode
}

declare class JSXMemberExpression {
  type: 'JSXMemberExpression';
  loc: ?Location;
  object: JSXMemberExpression | JSXIdentifier;
  property: JSXIdentifier;

  // alias: JSX
  // alias: BabelNode
}

declare class JSXNamespacedName {
  type: 'JSXNamespacedName';
  loc: ?Location;
  namespace: JSXIdentifier;
  name: JSXIdentifier;

  // alias: JSX
  // alias: BabelNode
}

declare class JSXOpeningElement {
  type: 'JSXOpeningElement';
  loc: ?Location;
  name: JSXIdentifier | JSXMemberExpression;
  attributes: $ReadOnlyArray<JSXAttribute | JSXSpreadAttribute>;
  selfClosing: boolean;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class JSXOpeningFragment {
  type: 'JSXOpeningFragment';
  loc: ?Location;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class JSXSpreadAttribute {
  type: 'JSXSpreadAttribute';
  loc: ?Location;
  argument: Expression;

  // alias: JSX
  // alias: BabelNode
}

declare class JSXSpreadChild {
  type: 'JSXSpreadChild';
  loc: ?Location;
  expression: Expression;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class JSXText {
  type: 'JSXText';
  loc: ?Location;
  value: string;

  // alias: JSX
  // alias: Immutable
  // alias: BabelNode
}

declare class LabeledStatement {
  type: 'LabeledStatement';
  loc: ?Location;
  label: Identifier;
  body: Statement;

  // alias: Statement
  // alias: BabelNode
}

declare class LogicalExpression {
  type: 'LogicalExpression';
  loc: ?Location;
  operator: '||' | '&&' | '??';
  left: Expression;
  right: Expression;

  // alias: Binary
  // alias: Expression
  // alias: BabelNode
}

declare class MemberExpression {
  type: 'MemberExpression';
  loc: ?Location;
  object: Expression;
  property: Expression;
  computed: boolean;
  optional: ?true | false;

  // alias: Expression
  // alias: LVal
  // alias: BabelNode
}

declare class MetaProperty {
  type: 'MetaProperty';
  loc: ?Location;
  meta: Identifier;
  property: Identifier;

  // alias: Expression
  // alias: BabelNode
}

declare class MixedTypeAnnotation {
  type: 'MixedTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowType
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class NewExpression {
  type: 'NewExpression';
  loc: ?Location;
  callee: Expression;
  arguments: $ReadOnlyArray<Expression | SpreadElement | JSXNamespacedName>;
  optional: ?true | false;
  typeParameters: ?TypeParameterInstantiation | TSTypeParameterInstantiation;

  // alias: Expression
  // alias: BabelNode
}

declare class Noop {
  type: 'Noop';
  loc: ?Location;

  // alias: BabelNode
}

declare class NullLiteral {
  type: 'NullLiteral';
  loc: ?Location;

  // alias: Expression
  // alias: Pureish
  // alias: Literal
  // alias: Immutable
  // alias: BabelNode
}

declare class NullLiteralTypeAnnotation {
  type: 'NullLiteralTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowType
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class NullableTypeAnnotation {
  type: 'NullableTypeAnnotation';
  loc: ?Location;
  typeAnnotation: FlowType;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class NumberLiteralTypeAnnotation {
  type: 'NumberLiteralTypeAnnotation';
  loc: ?Location;
  value: ?number;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class NumberTypeAnnotation {
  type: 'NumberTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowType
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class NumericLiteral {
  type: 'NumericLiteral';
  loc: ?Location;
  value: number;

  // alias: Expression
  // alias: Pureish
  // alias: Literal
  // alias: Immutable
  // alias: BabelNode
}

declare class ObjectExpression {
  type: 'ObjectExpression';
  loc: ?Location;
  properties: $ReadOnlyArray<ObjectMethod | ObjectProperty | SpreadElement>;

  // alias: Expression
  // alias: BabelNode
}

declare class ObjectMethod {
  type: 'ObjectMethod';
  loc: ?Location;
  kind: "method" | "get" | "set";
  key: Expression;
  params: $ReadOnlyArray<LVal>;
  body: BlockStatement;
  computed: boolean;
  async: ?boolean;
  decorators: ?$ReadOnlyArray<Decorator>;
  generator: ?boolean;
  returnType: ?TypeAnnotation | TSTypeAnnotation | Noop;
  typeParameters: ?TypeParameterDeclaration | TSTypeParameterDeclaration | Noop;

  // alias: UserWhitespacable
  // alias: Function
  // alias: Scopable
  // alias: BlockParent
  // alias: FunctionParent
  // alias: Method
  // alias: ObjectMember
  // alias: BabelNode
}

declare class ObjectPattern {
  type: 'ObjectPattern';
  loc: ?Location;
  properties: $ReadOnlyArray<RestElement | ObjectProperty>;
  decorators: ?$ReadOnlyArray<Decorator>;
  typeAnnotation: ?TypeAnnotation | TSTypeAnnotation | Noop;

  // alias: Pattern
  // alias: PatternLike
  // alias: LVal
  // alias: BabelNode
}

declare class ObjectProperty {
  type: 'ObjectProperty';
  loc: ?Location;
  key: Expression;
  value: Expression | PatternLike;
  computed: boolean;
  shorthand: boolean;
  decorators: ?$ReadOnlyArray<Decorator>;

  // alias: UserWhitespacable
  // alias: Property
  // alias: ObjectMember
  // alias: BabelNode
}

declare class ObjectTypeAnnotation {
  type: 'ObjectTypeAnnotation';
  loc: ?Location;
  properties: $ReadOnlyArray<ObjectTypeProperty | ObjectTypeSpreadProperty>;
  indexers: ?$ReadOnlyArray<ObjectTypeIndexer>;
  callProperties: ?$ReadOnlyArray<ObjectTypeCallProperty>;
  exact: ?boolean;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class ObjectTypeCallProperty {
  type: 'ObjectTypeCallProperty';
  loc: ?Location;
  value: FlowType;

  // alias: Flow
  // alias: UserWhitespacable
  // alias: BabelNode
}

declare class ObjectTypeIndexer {
  type: 'ObjectTypeIndexer';
  loc: ?Location;
  id: ?Identifier;
  key: FlowType;
  value: FlowType;
  variance: ?Variance;

  // alias: Flow
  // alias: UserWhitespacable
  // alias: BabelNode
}

declare class ObjectTypeProperty {
  type: 'ObjectTypeProperty';
  loc: ?Location;
  key: Identifier;
  value: FlowType;
  variance: ?Variance;
  kind: ?'init' | 'get' | 'set';
  optional: ?boolean;

  // alias: Flow
  // alias: UserWhitespacable
  // alias: BabelNode
}

declare class ObjectTypeSpreadProperty {
  type: 'ObjectTypeSpreadProperty';
  loc: ?Location;
  argument: FlowType;

  // alias: Flow
  // alias: UserWhitespacable
  // alias: BabelNode
}

declare class OpaqueType {
  type: 'OpaqueType';
  loc: ?Location;
  id: Identifier;
  typeParameters: ?TypeParameterDeclaration;
  supertype: ?FlowType;
  impltype: FlowType;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class ParenthesizedExpression {
  type: 'ParenthesizedExpression';
  loc: ?Location;
  expression: Expression;

  // alias: Expression
  // alias: ExpressionWrapper
  // alias: BabelNode
}

declare class Program {
  type: 'Program';
  loc: ?Location;
  body: $ReadOnlyArray<Statement>;
  directives: $ReadOnlyArray<Directive>;
  sourceType: 'script' | 'module';
  sourceFile: ?string;

  // alias: Scopable
  // alias: BlockParent
  // alias: Block
  // alias: BabelNode
}

declare class QualifiedTypeIdentifier {
  type: 'QualifiedTypeIdentifier';
  loc: ?Location;
  id: Identifier;
  qualification: Identifier | QualifiedTypeIdentifier;

  // alias: Flow
  // alias: BabelNode
}

declare class RegExpLiteral {
  type: 'RegExpLiteral';
  loc: ?Location;
  pattern: string;
  flags: string;

  // alias: Expression
  // alias: Literal
  // alias: BabelNode
}

declare class RestElement {
  type: 'RestElement';
  loc: ?Location;
  argument: LVal;
  decorators: ?$ReadOnlyArray<Decorator>;
  typeAnnotation: ?TypeAnnotation | TSTypeAnnotation | Noop;

  // alias: LVal
  // alias: PatternLike
  // alias: BabelNode
}

declare class ReturnStatement {
  type: 'ReturnStatement';
  loc: ?Location;
  argument: ?Expression;

  // alias: Statement
  // alias: Terminatorless
  // alias: CompletionStatement
  // alias: BabelNode
}

declare class SequenceExpression {
  type: 'SequenceExpression';
  loc: ?Location;
  expressions: $ReadOnlyArray<Expression>;

  // alias: Expression
  // alias: BabelNode
}

declare class SpreadElement {
  type: 'SpreadElement';
  loc: ?Location;
  argument: Expression;

  // alias: UnaryLike
  // alias: BabelNode
}

declare class StringLiteral {
  type: 'StringLiteral';
  loc: ?Location;
  value: string;

  // alias: Expression
  // alias: Pureish
  // alias: Literal
  // alias: Immutable
  // alias: BabelNode
}

declare class StringLiteralTypeAnnotation {
  type: 'StringLiteralTypeAnnotation';
  loc: ?Location;
  value: ?string;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class StringTypeAnnotation {
  type: 'StringTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowType
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class Super {
  type: 'Super';
  loc: ?Location;

  // alias: Expression
  // alias: BabelNode
}

declare class SwitchCase {
  type: 'SwitchCase';
  loc: ?Location;
  test: ?Expression;
  consequent: $ReadOnlyArray<Statement>;

  // alias: BabelNode
}

declare class SwitchStatement {
  type: 'SwitchStatement';
  loc: ?Location;
  discriminant: Expression;
  cases: $ReadOnlyArray<SwitchCase>;

  // alias: Statement
  // alias: BlockParent
  // alias: Scopable
  // alias: BabelNode
}

declare class TSAnyKeyword {
  type: 'TSAnyKeyword';
  loc: ?Location;

  // alias: TSType
  // alias: BabelNode
}

declare class TSArrayType {
  type: 'TSArrayType';
  loc: ?Location;
  elementType: TSType;

  // alias: TSType
  // alias: BabelNode
}

declare class TSAsExpression {
  type: 'TSAsExpression';
  loc: ?Location;
  expression: Expression;
  typeAnnotation: TSType;

  // alias: Expression
  // alias: BabelNode
}

declare class TSBooleanKeyword {
  type: 'TSBooleanKeyword';
  loc: ?Location;

  // alias: TSType
  // alias: BabelNode
}

declare class TSCallSignatureDeclaration {
  type: 'TSCallSignatureDeclaration';
  loc: ?Location;
  typeParameters: ?TSTypeParameterDeclaration;
  parameters: ?$ReadOnlyArray<Identifier | RestElement>;
  typeAnnotation: ?TSTypeAnnotation;

  // alias: TSTypeElement
  // alias: BabelNode
}

declare class TSConstructSignatureDeclaration {
  type: 'TSConstructSignatureDeclaration';
  loc: ?Location;
  typeParameters: ?TSTypeParameterDeclaration;
  parameters: ?$ReadOnlyArray<Identifier | RestElement>;
  typeAnnotation: ?TSTypeAnnotation;

  // alias: TSTypeElement
  // alias: BabelNode
}

declare class TSConstructorType {
  type: 'TSConstructorType';
  loc: ?Location;
  typeParameters: ?TSTypeParameterDeclaration;
  typeAnnotation: ?TSTypeAnnotation;
  parameters: ?$ReadOnlyArray<Identifier | RestElement>;

  // alias: TSType
  // alias: BabelNode
}

declare class TSDeclareFunction {
  type: 'TSDeclareFunction';
  loc: ?Location;
  id: ?Identifier;
  typeParameters: ?TSTypeParameterDeclaration | Noop;
  params: $ReadOnlyArray<LVal>;
  returnType: ?TSTypeAnnotation | Noop;
  async: ?boolean;
  declare: ?boolean;
  generator: ?boolean;

  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class TSDeclareMethod {
  type: 'TSDeclareMethod';
  loc: ?Location;
  decorators: ?$ReadOnlyArray<Decorator>;
  key: mixed;
  typeParameters: ?TSTypeParameterDeclaration | Noop;
  params: $ReadOnlyArray<LVal>;
  returnType: ?TSTypeAnnotation | Noop;
  abstract: ?boolean;
  access: ?"public" | "private" | "protected";
  accessibility: ?"public" | "private" | "protected";
  async: ?boolean;
  computed: ?boolean;
  generator: ?boolean;
  kind: ?"get" | "set" | "method" | "constructor";
  optional: ?boolean;

  // alias: BabelNode
}

declare class TSEnumDeclaration {
  type: 'TSEnumDeclaration';
  loc: ?Location;
  id: Identifier;
  members: $ReadOnlyArray<TSEnumMember>;
  const: ?boolean;
  declare: ?boolean;
  initializer: ?Expression;

  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class TSEnumMember {
  type: 'TSEnumMember';
  loc: ?Location;
  id: Identifier | StringLiteral;
  initializer: ?Expression;

  // alias: BabelNode
}

declare class TSExportAssignment {
  type: 'TSExportAssignment';
  loc: ?Location;
  expression: Expression;

  // alias: Statement
  // alias: BabelNode
}

declare class TSExpressionWithTypeArguments {
  type: 'TSExpressionWithTypeArguments';
  loc: ?Location;
  expression: TSEntityName;
  typeParameters: ?TSTypeParameterInstantiation;

  // alias: TSType
  // alias: BabelNode
}

declare class TSExternalModuleReference {
  type: 'TSExternalModuleReference';
  loc: ?Location;
  expression: StringLiteral;

  // alias: BabelNode
}

declare class TSFunctionType {
  type: 'TSFunctionType';
  loc: ?Location;
  typeParameters: ?TSTypeParameterDeclaration;
  typeAnnotation: ?TSTypeAnnotation;
  parameters: ?$ReadOnlyArray<Identifier | RestElement>;

  // alias: TSType
  // alias: BabelNode
}

declare class TSImportEqualsDeclaration {
  type: 'TSImportEqualsDeclaration';
  loc: ?Location;
  id: Identifier;
  moduleReference: TSEntityName | TSExternalModuleReference;
  isExport: ?boolean;

  // alias: Statement
  // alias: BabelNode
}

declare class TSIndexSignature {
  type: 'TSIndexSignature';
  loc: ?Location;
  parameters: $ReadOnlyArray<Identifier>;
  typeAnnotation: ?TSTypeAnnotation;
  readonly: ?boolean;

  // alias: TSTypeElement
  // alias: BabelNode
}

declare class TSIndexedAccessType {
  type: 'TSIndexedAccessType';
  loc: ?Location;
  objectType: TSType;
  indexType: TSType;

  // alias: TSType
  // alias: BabelNode
}

declare class TSInterfaceBody {
  type: 'TSInterfaceBody';
  loc: ?Location;
  body: $ReadOnlyArray<TSTypeElement>;

  // alias: BabelNode
}

declare class TSInterfaceDeclaration {
  type: 'TSInterfaceDeclaration';
  loc: ?Location;
  id: Identifier;
  typeParameters: ?TSTypeParameterDeclaration;
  extends: ?$ReadOnlyArray<TSExpressionWithTypeArguments>;
  body: TSInterfaceBody;
  declare: ?boolean;

  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class TSIntersectionType {
  type: 'TSIntersectionType';
  loc: ?Location;
  types: $ReadOnlyArray<TSType>;

  // alias: TSType
  // alias: BabelNode
}

declare class TSLiteralType {
  type: 'TSLiteralType';
  loc: ?Location;
  literal: NumericLiteral | StringLiteral | BooleanLiteral;

  // alias: TSType
  // alias: BabelNode
}

declare class TSMappedType {
  type: 'TSMappedType';
  loc: ?Location;
  typeParameter: TSTypeParameter;
  typeAnnotation: ?TSType;
  optional: ?boolean;
  readonly: ?boolean;

  // alias: TSType
  // alias: BabelNode
}

declare class TSMethodSignature {
  type: 'TSMethodSignature';
  loc: ?Location;
  key: Expression;
  typeParameters: ?TSTypeParameterDeclaration;
  parameters: ?$ReadOnlyArray<Identifier | RestElement>;
  typeAnnotation: ?TSTypeAnnotation;
  computed: ?boolean;
  optional: ?boolean;

  // alias: TSTypeElement
  // alias: BabelNode
}

declare class TSModuleBlock {
  type: 'TSModuleBlock';
  loc: ?Location;
  body: $ReadOnlyArray<Statement>;

  // alias: BabelNode
}

declare class TSModuleDeclaration {
  type: 'TSModuleDeclaration';
  loc: ?Location;
  id: Identifier | StringLiteral;
  body: TSModuleBlock | TSModuleDeclaration;
  declare: ?boolean;
  global: ?boolean;

  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class TSNamespaceExportDeclaration {
  type: 'TSNamespaceExportDeclaration';
  loc: ?Location;
  id: Identifier;

  // alias: Statement
  // alias: BabelNode
}

declare class TSNeverKeyword {
  type: 'TSNeverKeyword';
  loc: ?Location;

  // alias: TSType
  // alias: BabelNode
}

declare class TSNonNullExpression {
  type: 'TSNonNullExpression';
  loc: ?Location;
  expression: Expression;

  // alias: Expression
  // alias: BabelNode
}

declare class TSNullKeyword {
  type: 'TSNullKeyword';
  loc: ?Location;

  // alias: TSType
  // alias: BabelNode
}

declare class TSNumberKeyword {
  type: 'TSNumberKeyword';
  loc: ?Location;

  // alias: TSType
  // alias: BabelNode
}

declare class TSObjectKeyword {
  type: 'TSObjectKeyword';
  loc: ?Location;

  // alias: TSType
  // alias: BabelNode
}

declare class TSParameterProperty {
  type: 'TSParameterProperty';
  loc: ?Location;
  parameter: Identifier | AssignmentPattern;
  accessibility: ?'public' | 'private' | 'protected';
  readonly: ?boolean;

  // alias: LVal
  // alias: BabelNode
}

declare class TSParenthesizedType {
  type: 'TSParenthesizedType';
  loc: ?Location;
  typeAnnotation: TSType;

  // alias: TSType
  // alias: BabelNode
}

declare class TSPropertySignature {
  type: 'TSPropertySignature';
  loc: ?Location;
  key: Expression;
  typeAnnotation: ?TSTypeAnnotation;
  initializer: ?Expression;
  computed: ?boolean;
  optional: ?boolean;
  readonly: ?boolean;

  // alias: TSTypeElement
  // alias: BabelNode
}

declare class TSQualifiedName {
  type: 'TSQualifiedName';
  loc: ?Location;
  left: TSEntityName;
  right: Identifier;

  // alias: TSEntityName
  // alias: BabelNode
}

declare class TSStringKeyword {
  type: 'TSStringKeyword';
  loc: ?Location;

  // alias: TSType
  // alias: BabelNode
}

declare class TSSymbolKeyword {
  type: 'TSSymbolKeyword';
  loc: ?Location;

  // alias: TSType
  // alias: BabelNode
}

declare class TSThisType {
  type: 'TSThisType';
  loc: ?Location;

  // alias: TSType
  // alias: BabelNode
}

declare class TSTupleType {
  type: 'TSTupleType';
  loc: ?Location;
  elementTypes: $ReadOnlyArray<TSType>;

  // alias: TSType
  // alias: BabelNode
}

declare class TSTypeAliasDeclaration {
  type: 'TSTypeAliasDeclaration';
  loc: ?Location;
  id: Identifier;
  typeParameters: ?TSTypeParameterDeclaration;
  typeAnnotation: TSType;
  declare: ?boolean;

  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class TSTypeAnnotation {
  type: 'TSTypeAnnotation';
  loc: ?Location;
  typeAnnotation: TSType;

  // alias: BabelNode
}

declare class TSTypeAssertion {
  type: 'TSTypeAssertion';
  loc: ?Location;
  typeAnnotation: TSType;
  expression: Expression;

  // alias: Expression
  // alias: BabelNode
}

declare class TSTypeLiteral {
  type: 'TSTypeLiteral';
  loc: ?Location;
  members: $ReadOnlyArray<TSTypeElement>;

  // alias: TSType
  // alias: BabelNode
}

declare class TSTypeOperator {
  type: 'TSTypeOperator';
  loc: ?Location;
  typeAnnotation: TSType;
  operator: ?string;

  // alias: TSType
  // alias: BabelNode
}

declare class TSTypeParameter {
  type: 'TSTypeParameter';
  loc: ?Location;
  constraint: ?TSType;
  default: ?TSType;
  name: ?string;

  // alias: BabelNode
}

declare class TSTypeParameterDeclaration {
  type: 'TSTypeParameterDeclaration';
  loc: ?Location;
  params: $ReadOnlyArray<TSTypeParameter>;

  // alias: BabelNode
}

declare class TSTypeParameterInstantiation {
  type: 'TSTypeParameterInstantiation';
  loc: ?Location;
  params: $ReadOnlyArray<TSType>;

  // alias: BabelNode
}

declare class TSTypePredicate {
  type: 'TSTypePredicate';
  loc: ?Location;
  parameterName: Identifier | TSThisType;
  typeAnnotation: TSTypeAnnotation;

  // alias: TSType
  // alias: BabelNode
}

declare class TSTypeQuery {
  type: 'TSTypeQuery';
  loc: ?Location;
  exprName: TSEntityName;

  // alias: TSType
  // alias: BabelNode
}

declare class TSTypeReference {
  type: 'TSTypeReference';
  loc: ?Location;
  typeName: TSEntityName;
  typeParameters: ?TSTypeParameterInstantiation;

  // alias: TSType
  // alias: BabelNode
}

declare class TSUndefinedKeyword {
  type: 'TSUndefinedKeyword';
  loc: ?Location;

  // alias: TSType
  // alias: BabelNode
}

declare class TSUnionType {
  type: 'TSUnionType';
  loc: ?Location;
  types: $ReadOnlyArray<TSType>;

  // alias: TSType
  // alias: BabelNode
}

declare class TSVoidKeyword {
  type: 'TSVoidKeyword';
  loc: ?Location;

  // alias: TSType
  // alias: BabelNode
}

declare class TaggedTemplateExpression {
  type: 'TaggedTemplateExpression';
  loc: ?Location;
  tag: Expression;
  quasi: TemplateLiteral;

  // alias: Expression
  // alias: BabelNode
}

declare class TemplateElement {
  type: 'TemplateElement';
  loc: ?Location;
  value: mixed;
  tail: boolean;

  // alias: BabelNode
}

declare class TemplateLiteral {
  type: 'TemplateLiteral';
  loc: ?Location;
  quasis: $ReadOnlyArray<TemplateElement>;
  expressions: $ReadOnlyArray<Expression>;

  // alias: Expression
  // alias: Literal
  // alias: BabelNode
}

declare class ThisExpression {
  type: 'ThisExpression';
  loc: ?Location;

  // alias: Expression
  // alias: BabelNode
}

declare class ThisTypeAnnotation {
  type: 'ThisTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowType
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class ThrowStatement {
  type: 'ThrowStatement';
  loc: ?Location;
  argument: Expression;

  // alias: Statement
  // alias: Terminatorless
  // alias: CompletionStatement
  // alias: BabelNode
}

declare class TryStatement {
  type: 'TryStatement';
  loc: ?Location;
  block: BlockStatement;
  handler: ?CatchClause;
  finalizer: ?BlockStatement;

  // alias: Statement
  // alias: BabelNode
}

declare class TupleTypeAnnotation {
  type: 'TupleTypeAnnotation';
  loc: ?Location;
  types: $ReadOnlyArray<FlowType>;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class TypeAlias {
  type: 'TypeAlias';
  loc: ?Location;
  id: Identifier;
  typeParameters: ?TypeParameterDeclaration;
  right: FlowType;

  // alias: Flow
  // alias: FlowDeclaration
  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class TypeAnnotation {
  type: 'TypeAnnotation';
  loc: ?Location;
  typeAnnotation: FlowType;

  // alias: Flow
  // alias: BabelNode
}

declare class TypeCastExpression {
  type: 'TypeCastExpression';
  loc: ?Location;
  expression: Expression;
  typeAnnotation: TypeAnnotation;

  // alias: Flow
  // alias: ExpressionWrapper
  // alias: Expression
  // alias: BabelNode
}

declare class TypeParameter {
  type: 'TypeParameter';
  loc: ?Location;
  bound: ?TypeAnnotation;
  default: ?FlowType;
  variance: ?Variance;
  name: ?string;

  // alias: Flow
  // alias: BabelNode
}

declare class TypeParameterDeclaration {
  type: 'TypeParameterDeclaration';
  loc: ?Location;
  params: $ReadOnlyArray<TypeParameter>;

  // alias: Flow
  // alias: BabelNode
}

declare class TypeParameterInstantiation {
  type: 'TypeParameterInstantiation';
  loc: ?Location;
  params: $ReadOnlyArray<FlowType>;

  // alias: Flow
  // alias: BabelNode
}

declare class TypeofTypeAnnotation {
  type: 'TypeofTypeAnnotation';
  loc: ?Location;
  argument: FlowType;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class UnaryExpression {
  type: 'UnaryExpression';
  loc: ?Location;
  operator: 'void' | 'throw' | 'delete' | '!' | '+' | '-' | '~' | 'typeof';
  argument: Expression;
  prefix: boolean;

  // alias: UnaryLike
  // alias: Expression
  // alias: BabelNode
}

declare class UnionTypeAnnotation {
  type: 'UnionTypeAnnotation';
  loc: ?Location;
  types: $ReadOnlyArray<FlowType>;

  // alias: Flow
  // alias: FlowType
  // alias: BabelNode
}

declare class UpdateExpression {
  type: 'UpdateExpression';
  loc: ?Location;
  operator: '++' | '--';
  argument: Expression;
  prefix: boolean;

  // alias: Expression
  // alias: BabelNode
}

declare class VariableDeclaration {
  type: 'VariableDeclaration';
  loc: ?Location;
  kind: "var" | "let" | "const";
  declarations: $ReadOnlyArray<VariableDeclarator>;
  declare: ?boolean;

  // alias: Statement
  // alias: Declaration
  // alias: BabelNode
}

declare class VariableDeclarator {
  type: 'VariableDeclarator';
  loc: ?Location;
  id: LVal;
  init: ?Expression;

  // alias: BabelNode
}

declare class VoidTypeAnnotation {
  type: 'VoidTypeAnnotation';
  loc: ?Location;

  // alias: Flow
  // alias: FlowType
  // alias: FlowBaseAnnotation
  // alias: BabelNode
}

declare class WhileStatement {
  type: 'WhileStatement';
  loc: ?Location;
  test: Expression;
  body: BlockStatement | Statement;

  // alias: Statement
  // alias: BlockParent
  // alias: Loop
  // alias: While
  // alias: Scopable
  // alias: BabelNode
}

declare class WithStatement {
  type: 'WithStatement';
  loc: ?Location;
  object: Expression;
  body: BlockStatement | Statement;

  // alias: Statement
  // alias: BabelNode
}

declare class YieldExpression {
  type: 'YieldExpression';
  loc: ?Location;
  argument: ?Expression;
  delegate: boolean;

  // alias: Expression
  // alias: Terminatorless
  // alias: BabelNode
}

type Flow = (
  | AnyTypeAnnotation
  | ArrayTypeAnnotation
  | BooleanLiteralTypeAnnotation
  | BooleanTypeAnnotation
  | ClassImplements
  | DeclareClass
  | DeclareExportAllDeclaration
  | DeclareExportDeclaration
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareOpaqueType
  | DeclareTypeAlias
  | DeclareVariable
  | DeclaredPredicate
  | EmptyTypeAnnotation
  | ExistsTypeAnnotation
  | FunctionTypeAnnotation
  | FunctionTypeParam
  | GenericTypeAnnotation
  | InferredPredicate
  | InterfaceDeclaration
  | InterfaceExtends
  | IntersectionTypeAnnotation
  | MixedTypeAnnotation
  | NullLiteralTypeAnnotation
  | NullableTypeAnnotation
  | NumberLiteralTypeAnnotation
  | NumberTypeAnnotation
  | ObjectTypeAnnotation
  | ObjectTypeCallProperty
  | ObjectTypeIndexer
  | ObjectTypeProperty
  | ObjectTypeSpreadProperty
  | OpaqueType
  | QualifiedTypeIdentifier
  | StringLiteralTypeAnnotation
  | StringTypeAnnotation
  | ThisTypeAnnotation
  | TupleTypeAnnotation
  | TypeAlias
  | TypeAnnotation
  | TypeCastExpression
  | TypeParameter
  | TypeParameterDeclaration
  | TypeParameterInstantiation
  | TypeofTypeAnnotation
  | UnionTypeAnnotation
  | VoidTypeAnnotation
);

type FlowType = (
  | AnyTypeAnnotation
  | ArrayTypeAnnotation
  | BooleanLiteralTypeAnnotation
  | BooleanTypeAnnotation
  | EmptyTypeAnnotation
  | ExistsTypeAnnotation
  | FunctionTypeAnnotation
  | GenericTypeAnnotation
  | IntersectionTypeAnnotation
  | MixedTypeAnnotation
  | NullLiteralTypeAnnotation
  | NullableTypeAnnotation
  | NumberLiteralTypeAnnotation
  | NumberTypeAnnotation
  | ObjectTypeAnnotation
  | StringLiteralTypeAnnotation
  | StringTypeAnnotation
  | ThisTypeAnnotation
  | TupleTypeAnnotation
  | TypeofTypeAnnotation
  | UnionTypeAnnotation
  | VoidTypeAnnotation
);

type FlowBaseAnnotation = (
  | AnyTypeAnnotation
  | BooleanTypeAnnotation
  | EmptyTypeAnnotation
  | MixedTypeAnnotation
  | NullLiteralTypeAnnotation
  | NumberTypeAnnotation
  | StringTypeAnnotation
  | ThisTypeAnnotation
  | VoidTypeAnnotation
);

type BabelNode = (
  | AnyTypeAnnotation
  | ArrayExpression
  | ArrayPattern
  | ArrayTypeAnnotation
  | ArrowFunctionExpression
  | AssignmentExpression
  | AssignmentPattern
  | AwaitExpression
  | BinaryExpression
  | BindExpression
  | BlockStatement
  | BooleanLiteral
  | BooleanLiteralTypeAnnotation
  | BooleanTypeAnnotation
  | BreakStatement
  | CallExpression
  | CatchClause
  | ClassBody
  | ClassDeclaration
  | ClassExpression
  | ClassImplements
  | ClassMethod
  | ClassProperty
  | ConditionalExpression
  | ContinueStatement
  | DebuggerStatement
  | DeclareClass
  | DeclareExportAllDeclaration
  | DeclareExportDeclaration
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareOpaqueType
  | DeclareTypeAlias
  | DeclareVariable
  | DeclaredPredicate
  | Decorator
  | Directive
  | DirectiveLiteral
  | DoExpression
  | DoWhileStatement
  | EmptyStatement
  | EmptyTypeAnnotation
  | ExistsTypeAnnotation
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportDefaultSpecifier
  | ExportNamedDeclaration
  | ExportNamespaceSpecifier
  | ExportSpecifier
  | ExpressionStatement
  | File
  | ForInStatement
  | ForOfStatement
  | ForStatement
  | FunctionDeclaration
  | FunctionExpression
  | FunctionTypeAnnotation
  | FunctionTypeParam
  | GenericTypeAnnotation
  | Identifier
  | IfStatement
  | Import
  | ImportDeclaration
  | ImportDefaultSpecifier
  | ImportNamespaceSpecifier
  | ImportSpecifier
  | InferredPredicate
  | InterfaceDeclaration
  | InterfaceExtends
  | IntersectionTypeAnnotation
  | JSXAttribute
  | JSXClosingElement
  | JSXClosingFragment
  | JSXElement
  | JSXEmptyExpression
  | JSXExpressionContainer
  | JSXFragment
  | JSXIdentifier
  | JSXMemberExpression
  | JSXNamespacedName
  | JSXOpeningElement
  | JSXOpeningFragment
  | JSXSpreadAttribute
  | JSXSpreadChild
  | JSXText
  | LabeledStatement
  | LogicalExpression
  | MemberExpression
  | MetaProperty
  | MixedTypeAnnotation
  | NewExpression
  | Noop
  | NullLiteral
  | NullLiteralTypeAnnotation
  | NullableTypeAnnotation
  | NumberLiteralTypeAnnotation
  | NumberTypeAnnotation
  | NumericLiteral
  | ObjectExpression
  | ObjectMethod
  | ObjectPattern
  | ObjectProperty
  | ObjectTypeAnnotation
  | ObjectTypeCallProperty
  | ObjectTypeIndexer
  | ObjectTypeProperty
  | ObjectTypeSpreadProperty
  | OpaqueType
  | ParenthesizedExpression
  | Program
  | QualifiedTypeIdentifier
  | RegExpLiteral
  | RestElement
  | ReturnStatement
  | SequenceExpression
  | SpreadElement
  | StringLiteral
  | StringLiteralTypeAnnotation
  | StringTypeAnnotation
  | Super
  | SwitchCase
  | SwitchStatement
  | TSAnyKeyword
  | TSArrayType
  | TSAsExpression
  | TSBooleanKeyword
  | TSCallSignatureDeclaration
  | TSConstructSignatureDeclaration
  | TSConstructorType
  | TSDeclareFunction
  | TSDeclareMethod
  | TSEnumDeclaration
  | TSEnumMember
  | TSExportAssignment
  | TSExpressionWithTypeArguments
  | TSExternalModuleReference
  | TSFunctionType
  | TSImportEqualsDeclaration
  | TSIndexSignature
  | TSIndexedAccessType
  | TSInterfaceBody
  | TSInterfaceDeclaration
  | TSIntersectionType
  | TSLiteralType
  | TSMappedType
  | TSMethodSignature
  | TSModuleBlock
  | TSModuleDeclaration
  | TSNamespaceExportDeclaration
  | TSNeverKeyword
  | TSNonNullExpression
  | TSNullKeyword
  | TSNumberKeyword
  | TSObjectKeyword
  | TSParameterProperty
  | TSParenthesizedType
  | TSPropertySignature
  | TSQualifiedName
  | TSStringKeyword
  | TSSymbolKeyword
  | TSThisType
  | TSTupleType
  | TSTypeAliasDeclaration
  | TSTypeAnnotation
  | TSTypeAssertion
  | TSTypeLiteral
  | TSTypeOperator
  | TSTypeParameter
  | TSTypeParameterDeclaration
  | TSTypeParameterInstantiation
  | TSTypePredicate
  | TSTypeQuery
  | TSTypeReference
  | TSUndefinedKeyword
  | TSUnionType
  | TSVoidKeyword
  | TaggedTemplateExpression
  | TemplateElement
  | TemplateLiteral
  | ThisExpression
  | ThisTypeAnnotation
  | ThrowStatement
  | TryStatement
  | TupleTypeAnnotation
  | TypeAlias
  | TypeAnnotation
  | TypeCastExpression
  | TypeParameter
  | TypeParameterDeclaration
  | TypeParameterInstantiation
  | TypeofTypeAnnotation
  | UnaryExpression
  | UnionTypeAnnotation
  | UpdateExpression
  | VariableDeclaration
  | VariableDeclarator
  | VoidTypeAnnotation
  | WhileStatement
  | WithStatement
  | YieldExpression
);

type Expression = (
  | ArrayExpression
  | ArrowFunctionExpression
  | AssignmentExpression
  | AwaitExpression
  | BinaryExpression
  | BindExpression
  | BooleanLiteral
  | CallExpression
  | ClassExpression
  | ConditionalExpression
  | DoExpression
  | FunctionExpression
  | Identifier
  | Import
  | JSXElement
  | JSXFragment
  | LogicalExpression
  | MemberExpression
  | MetaProperty
  | NewExpression
  | NullLiteral
  | NumericLiteral
  | ObjectExpression
  | ParenthesizedExpression
  | RegExpLiteral
  | SequenceExpression
  | StringLiteral
  | Super
  | TSAsExpression
  | TSNonNullExpression
  | TSTypeAssertion
  | TaggedTemplateExpression
  | TemplateLiteral
  | ThisExpression
  | TypeCastExpression
  | UnaryExpression
  | UpdateExpression
  | YieldExpression
);

type Pattern = (
  | ArrayPattern
  | AssignmentPattern
  | ObjectPattern
);

type PatternLike = (
  | ArrayPattern
  | AssignmentPattern
  | Identifier
  | ObjectPattern
  | RestElement
);

type LVal = (
  | ArrayPattern
  | AssignmentPattern
  | Identifier
  | MemberExpression
  | ObjectPattern
  | RestElement
  | TSParameterProperty
);

type Scopable = (
  | ArrowFunctionExpression
  | BlockStatement
  | CatchClause
  | ClassDeclaration
  | ClassExpression
  | ClassMethod
  | DoWhileStatement
  | ForInStatement
  | ForOfStatement
  | ForStatement
  | FunctionDeclaration
  | FunctionExpression
  | ObjectMethod
  | Program
  | SwitchStatement
  | WhileStatement
);

type Function = (
  | ArrowFunctionExpression
  | ClassMethod
  | FunctionDeclaration
  | FunctionExpression
  | ObjectMethod
);

type BlockParent = (
  | ArrowFunctionExpression
  | BlockStatement
  | CatchClause
  | ClassMethod
  | DoWhileStatement
  | ForInStatement
  | ForOfStatement
  | ForStatement
  | FunctionDeclaration
  | FunctionExpression
  | ObjectMethod
  | Program
  | SwitchStatement
  | WhileStatement
);

type FunctionParent = (
  | ArrowFunctionExpression
  | ClassMethod
  | FunctionDeclaration
  | FunctionExpression
  | ObjectMethod
);

type Pureish = (
  | ArrowFunctionExpression
  | BooleanLiteral
  | ClassDeclaration
  | ClassExpression
  | FunctionDeclaration
  | FunctionExpression
  | NullLiteral
  | NumericLiteral
  | StringLiteral
);

type Terminatorless = (
  | AwaitExpression
  | BreakStatement
  | ContinueStatement
  | ReturnStatement
  | ThrowStatement
  | YieldExpression
);

type Binary = (
  | BinaryExpression
  | LogicalExpression
);

type Block = (
  | BlockStatement
  | Program
);

type Statement = (
  | BlockStatement
  | BreakStatement
  | ClassDeclaration
  | ContinueStatement
  | DebuggerStatement
  | DeclareClass
  | DeclareExportAllDeclaration
  | DeclareExportDeclaration
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareOpaqueType
  | DeclareTypeAlias
  | DeclareVariable
  | DoWhileStatement
  | EmptyStatement
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
  | ExpressionStatement
  | ForInStatement
  | ForOfStatement
  | ForStatement
  | FunctionDeclaration
  | IfStatement
  | ImportDeclaration
  | InterfaceDeclaration
  | LabeledStatement
  | OpaqueType
  | ReturnStatement
  | SwitchStatement
  | TSDeclareFunction
  | TSEnumDeclaration
  | TSExportAssignment
  | TSImportEqualsDeclaration
  | TSInterfaceDeclaration
  | TSModuleDeclaration
  | TSNamespaceExportDeclaration
  | TSTypeAliasDeclaration
  | ThrowStatement
  | TryStatement
  | TypeAlias
  | VariableDeclaration
  | WhileStatement
  | WithStatement
);

type Literal = (
  | BooleanLiteral
  | NullLiteral
  | NumericLiteral
  | RegExpLiteral
  | StringLiteral
  | TemplateLiteral
);

type Immutable = (
  | BooleanLiteral
  | JSXAttribute
  | JSXClosingElement
  | JSXClosingFragment
  | JSXElement
  | JSXExpressionContainer
  | JSXFragment
  | JSXOpeningElement
  | JSXOpeningFragment
  | JSXSpreadChild
  | JSXText
  | NullLiteral
  | NumericLiteral
  | StringLiteral
);

type CompletionStatement = (
  | BreakStatement
  | ContinueStatement
  | ReturnStatement
  | ThrowStatement
);

type Class = (
  | ClassDeclaration
  | ClassExpression
);

type Declaration = (
  | ClassDeclaration
  | DeclareClass
  | DeclareExportAllDeclaration
  | DeclareExportDeclaration
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareOpaqueType
  | DeclareTypeAlias
  | DeclareVariable
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
  | FunctionDeclaration
  | ImportDeclaration
  | InterfaceDeclaration
  | OpaqueType
  | TSDeclareFunction
  | TSEnumDeclaration
  | TSInterfaceDeclaration
  | TSModuleDeclaration
  | TSTypeAliasDeclaration
  | TypeAlias
  | VariableDeclaration
);

type Method = (
  | ClassMethod
  | ObjectMethod
);

type Property = (
  | ClassProperty
  | ObjectProperty
);

type Conditional = (
  | ConditionalExpression
  | IfStatement
);

type FlowDeclaration = (
  | DeclareClass
  | DeclareExportAllDeclaration
  | DeclareExportDeclaration
  | DeclareFunction
  | DeclareInterface
  | DeclareModule
  | DeclareModuleExports
  | DeclareOpaqueType
  | DeclareTypeAlias
  | DeclareVariable
  | InterfaceDeclaration
  | OpaqueType
  | TypeAlias
);

type FlowPredicate = (
  | DeclaredPredicate
  | InferredPredicate
);

type Loop = (
  | DoWhileStatement
  | ForInStatement
  | ForOfStatement
  | ForStatement
  | WhileStatement
);

type While = (
  | DoWhileStatement
  | WhileStatement
);

type ModuleDeclaration = (
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
  | ImportDeclaration
);

type ExportDeclaration = (
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
);

type ModuleSpecifier = (
  | ExportDefaultSpecifier
  | ExportNamespaceSpecifier
  | ExportSpecifier
  | ImportDefaultSpecifier
  | ImportNamespaceSpecifier
  | ImportSpecifier
);

type ExpressionWrapper = (
  | ExpressionStatement
  | ParenthesizedExpression
  | TypeCastExpression
);

type For = (
  | ForInStatement
  | ForOfStatement
  | ForStatement
);

type ForXStatement = (
  | ForInStatement
  | ForOfStatement
);

type TSEntityName = (
  | Identifier
  | TSQualifiedName
);

type JSX = (
  | JSXAttribute
  | JSXClosingElement
  | JSXClosingFragment
  | JSXElement
  | JSXEmptyExpression
  | JSXExpressionContainer
  | JSXFragment
  | JSXIdentifier
  | JSXMemberExpression
  | JSXNamespacedName
  | JSXOpeningElement
  | JSXOpeningFragment
  | JSXSpreadAttribute
  | JSXSpreadChild
  | JSXText
);

type UserWhitespacable = (
  | ObjectMethod
  | ObjectProperty
  | ObjectTypeCallProperty
  | ObjectTypeIndexer
  | ObjectTypeProperty
  | ObjectTypeSpreadProperty
);

type ObjectMember = (
  | ObjectMethod
  | ObjectProperty
);

type UnaryLike = (
  | SpreadElement
  | UnaryExpression
);

type TSType = (
  | TSAnyKeyword
  | TSArrayType
  | TSBooleanKeyword
  | TSConstructorType
  | TSExpressionWithTypeArguments
  | TSFunctionType
  | TSIndexedAccessType
  | TSIntersectionType
  | TSLiteralType
  | TSMappedType
  | TSNeverKeyword
  | TSNullKeyword
  | TSNumberKeyword
  | TSObjectKeyword
  | TSParenthesizedType
  | TSStringKeyword
  | TSSymbolKeyword
  | TSThisType
  | TSTupleType
  | TSTypeLiteral
  | TSTypeOperator
  | TSTypePredicate
  | TSTypeQuery
  | TSTypeReference
  | TSUndefinedKeyword
  | TSUnionType
  | TSVoidKeyword
);

type TSTypeElement = (
  | TSCallSignatureDeclaration
  | TSConstructSignatureDeclaration
  | TSIndexSignature
  | TSMethodSignature
  | TSPropertySignature
);

type JSXValue = JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement;